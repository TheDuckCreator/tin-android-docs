{
  
  "0": {
    "title": "",
    "content": "404 . Page not found :( . The requested page could not be found. .",
    "url": "/tin-android-docs/404.html",
    "relUrl": "/404.html"
  }
  ,"1": {
    "title": "Basic Kotlin Lang",
    "content": "Intro To Kotlin Programing . Prepare for Project Preparation Using Ecilipse IDE and Kotlin Marketplace Extension . Learn Kotlin: https://kotlinlang.org/docs/reference . This is only my note during learning and coding something may be mistake. . Theethawat Savastham | Student at Prince of Songkla University Hatyai Thailand (At first I cannot typing in Thai in Ecilipse IDE) Now I learn in IntelliJ IDEA it can type in Thai but I’m idle. | . Structure . Don’t Need a Pre-processor because Kotlin is initial itself at the begining from IDE | Don’t worry about package name, It nescessory only to show that it are in the same domain. In file system they don’t show in class view but in IDE it will show you the structure of class | Function Initial run with main | No Semicolon needed in Kotlin Table of Content . | Basic Syntax | Function | Variable | String Management | Array | Class | . Basic Syntax . printing out the word . //using print or println print(&quot;Hello World&quot;) . printing out the value of variable . It can be inside the double quote with $ sign using variable Name . print(&quot; $variablename &quot;) //If have any calculating print(&quot; ${variableName1 + variableName2}&quot;) . Function . To call using like in C Language | Using fun to initial the function | . Function Prototype . fun functionName(parameterName:ParameterType): Returntype{ } . Example for Very Basic Function (don’t have return) . fun sum(a:Int,b:Int){ println(&quot;a is $a b is $b&quot;) } . Call function to use Return Value . In variable define or redefine . var x = functionName(Parameter) var y:Int y = functionName(Parameter) . Beware Function and Properties are not the same . Using the properties . In Properties we use to get something from variable you can using Kotlin Library properties . Calling Properties | . var testLengthVariable = &quot;Theethawat&quot; var theethawatLength =&quot;Theethawat&quot;.length . Or calling in print statement | . println(&quot;Variable of testLengthVariable is ${testLengthVariable.length}&quot;) . Variable . Using val can be assign a value only once | Using var can be reassign | Can use both Type define or not, if you not define a type you must initial value in the declare variable part and Kotlin will assign the type automatically | Type Define and value Define is optional All are correct | . var a:Int =1 var a = 2 var a:Int . This is example that Incorrect | . var a . Variable can define both in global and local (Private to function) if it be global it can be modify by any function without re parameter-initial like | . var x = 0 fun incrementX() { x += 1 } . ## String Management ### Triming Margin Can use trimMargin using with prefix ‘|’ only if use another prefix using trimMargin(‘Prefix’) . val str3 = &quot;&quot;&quot; #Hello World&quot;&quot;&quot;.trimMargin() val str4 = &quot;&quot;&quot; #Hello World &quot;&quot;&quot;.trimMargin(&quot;#&quot;) . Can use .trimIndent for trim white space before text like a white space and Can use triple quote “”” for let string in the string can be multiple line as we code . ## Array ### Array Declaring Can Creating Array with Initial Value , Initial Value Using Function or Uninitialized using normal form arrayOf if you initial value . val a = intArrayOf(11,13,15,17,12) . or using Specific type of Array . BooleanArray booleanArrayOf(true, false) | ByteArray byteArrayOf(1, 2, 3) | CharArray charArrayOf(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) | DoubleArray doubleArrayOf(1.2, 5.0) | FloatArray floatArrayOf(1.2, 5.0) | IntArray intArrayOf(1, 2, 3) | LongArray longArrayOf(1, 2, 3) | ShortArray shortArrayOf(1, 2, 3) | . or can design array by using function like . val asc = Array(5,init = {i-&gt;i+1}) for (b in asc){ println(b) } . ### Array Properties . Properties that can use when declare an Array sortedArray(), sortedArrayDescending() | Properties that can use when we using function sort(), sortDescending() , min(), max(),first(), last() it will return a view of the things that you want in array (some only for Int or Number Variables) for example . println(&quot;List of Array B is ${b.sorted()}&quot;) ### Collection Collection is like array but it&#39;s the tool that can easier management . | List use Listof() (Can replace string with other type) . val myList = listOf&lt;String&gt;(&quot;Theethawat&quot;,&quot;Songpon&quot;) . | Map use mapOf() . val myMap = mapOf&lt;Int,String&gt;(Pair(1,&quot;Theethawat&quot;), Pair(2,&quot;Theematach&quot;)) . | Set use setOf() . val mySet = setOf&lt;String&gt;(&quot;Theethawat&quot;,&quot;Sirinuch&quot;) using 3 types of collection and other type of Array can be random access ## Class ### Basic Concept of Class . | It’s like class in Java and sometime it’s like stucture in C in my own opinion | Use function (main or any) to call a class | If Compare to Java it has 3 part Field for variable declare and initial (Java divide into field and Constructor) and can use argument also() to make this variable call the function like val nameInput = &quot;The Input value is $name&quot;.also(::println) | init() can use for initial, set value and call function in class | function fun() | . | Everythings contain public, protected, private same like other OOP | Can use dot(.) for go to the attribute like in C or Java | For Example in file Address.kt | . Object . Companion object . If your class have a Companion object show that you can implement or adding the function to that object like . class MyClass { companion object { } // will be called &quot;Companion&quot; } fun MyClass.Companion.printCompanion() { println(&quot;theethawat&quot;) } fun main() { MyClass.printCompanion() } You will got an output &quot;Theethawat&quot;, i pick it from official Document at [Object Documents in Kotlin](https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects) . Basic Function and library . Kotlin will add Basic Library name kotlin.* if you use IDE or compiler | There include many function inside | String Function Reference is located at https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html | .",
    "url": "/tin-android-docs/AndroidFundamental/BasicKotlin.html",
    "relUrl": "/AndroidFundamental/BasicKotlin.html"
  }
  ,"2": {
    "title": "DataBinding",
    "content": "Android Layout with Kotlin Databinding . Pre-Request . Activatate Databinding . Enable Databinding in build.gradle file that app part inside android{} tag . dataBinding { enabled = true } . After That Sync your app . Basic Viewbinding . Layout Compatible . if you using linear layout add layout &lt;layout&gt; .... linear layout ..... &lt;/layout&gt; over there and move layout name space like xmlns:android=&quot;......&quot; to this layout and Build your App . Programing . go to MainActivity.kt or other program file . Active Binding Variable using lateinit that is predefine without value initial like . private lateinit var binding: ActivityMainBinding . | Set Content View Using Data Binding everything using the attribute of variable that have define in the previous step . binding = DataBindingUtil.setContentView(this,R.layout.activity_main) . | . this tell you that ‘this activity’ and R.layout.activity_main show that layout that you want to bind or showing . Databinding will generate A Specific Variable Name of Attribute like nickname_show to nicknameShow using Camel Case that automatically making by an IDE . Activity Recieving . Using Binding Variable in this code using bind in syntax using dot method like binding.doneButton.setOnClickListener { addNickname(it) } . it in Kotlin like this in Java to call compiler that I want to make function on this class ### Managing Activity . | Using Binding Variable and dot syntax like binding.nicknameShow.text = binding.nicknameInput.text . | Using binding.apply{...} to easy managing code (binding is Binding Variable) | Using invalidateAll() to invaluate data (Get new data) when Refresh UI | Example on this program binding.apply { binding.nicknameShow.text = binding.nicknameInput.text invalidateAll() /* to invaluate data (Get new data) when Refresh UI */ binding.nicknameInput.visibility = View.GONE binding.doneButton.visibility = View.GONE binding.nicknameShow.visibility = View.VISIBLE } . Using Attribute As same as using findViewById . | . Recommended Data-Binding . Using Data Class (in Another Kotlin File) for keep the object type variable like the stuct in C or can use any class instead of data class | Link The Layout to that class &lt;data&gt; &lt;variable name=&quot;myName&quot; type=&quot;com.example.aboutme.MyName&quot;/&gt; &lt;/data&gt; . The name of the variable you can define but link to your data class or Any structure class. . | .",
    "url": "/tin-android-docs/AndroidFundamental/DataBinding.html",
    "relUrl": "/AndroidFundamental/DataBinding.html"
  }
  ,"3": {
    "title": "LiveData",
    "content": "LiveData and LiveData Observer . เรื่องนี้เป็นเรื่องที่ต่อเนื่องจาก ViewModel และนำมาจาก Google Codelabs ของ Android Kotlin Fundamental . LiveData คือ คลาสที่คอยสังเกตุการเปลี่ยนแปลงของข้อมูล และ ตัวมันก็แบกข้อมูลด้วย (LiveData is observable and LiveData holds data) ด้วยความสามารถนี้ LiveData จึงมี Attribute ที่ผู้เขียนโปรแกรมสามารถเอาไว้ตรวจสอบการเปลี่ยนแปลงของข้อมูลได้ . นอกจากนั้น LiveData ยังเป็น lifecycle-aware คือ จะจัดการ อัพเดท และ แจ้งเตือน เฉพาะใน lifecycle ที่มันอยู่เท่านั้น เช่น onCreate(), onStart() หมด lifecycle ของมันก็ไม่ทำ . MutableLiveData . MutableLiveData คือ LiveData ที่ค่าด้านในนั้นสามารถเปลี่ยนไปได้ เนื่องจากมันเป็นคลาสทั่วไป เราก็ต้องใส่ Type ของข้อมูลที่จะให้มันแบกเอาไว้ เช่น . val word = MutableLiveData&lt;String&gt;() . ในการเซ็ทข้อมูลในตัวแปร เราจะใช้การเข้าไปที่ฟังก์ชัน setValue() ซึ่งในภาษา Kotlin เราสามารเขียนได้โดยใช้ .value แทน . word.value = &quot;Hello&quot; . หลังจากนั้น เราจะใช้ฟังก์ชัน minus(ค่าที่จะลบออก) และ plus(ค่าที่จะบวกเข้า) ในการลบ หรือ เพิ่มค่า ในบาง Record โดยจะเรียกใช้แบบ Null Safety (ใช้ ?หรือ!! เข้ามาช่วย ตามกรณี ๆ ไป) โดยเราจะต้องลบออกจาก Value หรือ อยู่ในฟังก์ชัน setValue() เสมอ เหมือนตัวอย่างข้างล่าง เราจะไปจัดการกับค่าของมันเท่านั้น ไม่ได้จัดการกับตัวแปร เช่น . score.value = (score.value)?.plus(1) . นอกจากนี้ MutableLiveData ยังสามารถใช้กับ Attribute อื่นได้ด้วย เช่นพวก removeAt() แต่จะต้องเป็นการแก้ไขที่ระดับ value โดยจะแก้ข้อมูลโดยใช้ Attribute ไหนก็ได้ของชนิดตัวแปรที่ได้ตั้งไว้ . word.value = wordList.removeAt(0) . Observer LiveData Object . Observer คือ การเขียนฟังก์ชัน Call back ง่าย ๆ ให้กับข้อมูลที่ได้มาจาก LiveData วิธีการเขียน Observer แบบง่าย ๆ ก็คือ การ getData ออกมาจากตัวแปรที่เก็บ ViewModel ไว้ จากนั้น .observe ดังนี้ . viewModel.score.observe(this,Observer{ newscore -&gt; }) . โดยที่ this ในที่นี่ เป็น Field ของ owner คือ Activity ตรงนี้ทำหน้าที่เป็น Owner ส่วน Observer {function} ทำหน้าที่เป็น Observer จากนั้นจะเป็นฟังก์ชันคอลแบค ซึ่งสามารถสั่งให้ตัวแปรทำอะไรก็ได้ เมื่อมีการเปลี่ยนแปลงที่ LiveData อย่างเช่น . viewModel.score.observe(this,Observer{newScore-&gt; binding.scoreText.text = newScore.toString() }) . แม้ว่าการทำงานจะออกมาเหมือนเดิม แต่เราจะเขียนโค้ดน้อยลง จะเป็นโปรแกรมที่ดีกว่า . Encapsulate LiveData . Encapsulation ในภาษาอังกฤษ แปลว่าการเสนอส่วนที่สำคัณที่สุด หรือ แปลว่าการจัดการที่เหมาะสม ในทางโปรแกรม คือ วิธีหนึ่งที่เราจะไม่เปิดเส้นทางให้ไปแก้ไขค่าในตัวแปรของ Object ตรง ๆ แต่จะใช้สร้างเป็น public method ที่จะให้มันไปแก้ไข private field ใน class ข้างในเอง . ในโค้ดก่อนหน้านี้ตาม Codelab เรายังไม่มีการทำ Encapsultation เพราะเราแก้ไขต่าง ๆ โดยตรง แต่ทางที่ดีเราไม่ควรจะทำอย่างนั้น เราควรจะให้การแก้ไขค่าต่าง ๆ เป็นการทำของ ViewModel เท่านั้น เพื่อเป็นการแยกงานเป็นส่วน ๆ แต่เรายังจำเป็นต้องอ่านข้อมูลเหล่านั้น โดย UI Controller ถ้าจะใช้ private เลยอาจจะไม่สะดวก จึงมี 2 ชนิดตัวแปร ให้ใช้แทน . MutableLiveData คือ ข้อมูลในออกเจ็กต์นี้สามารถเปลี่ยนได้ จากข้างในและนอก ViewModel | LiveData คือ ข้อมูลที่ถูกเก็บเข้าไปในชนิดนี้ สามรถอ่านได้เท่านั้น ไม่สามารนำมาแก้ไขได้ | . Backing Property . ฺBacking Property เป็นวิธีหนึ่งในภาษา Kotlin ซี่งอนุญาติให้ get method (getter) สามารถเข้าถึง Object ได้ และส่งออกค่าบางอย่างที่ต้องการได้ โดยที่ค่านั้นที่ไม่ใช่ตัว Object นั้นจริง ๆ วิธีนี้สามารถเอามาประยุกต์กับ การใช้ LiveData ได้ เพราะ LiveData นั้น แก้ไขไม่ได้ . วิธีนี้มีขั้นตอนคือ สร้างตัวแปรอีกตัวหนึ่งที่เป็น MutableLiveData&lt;&gt; เคียงคู่กับตัวแปรที่เราเก็บข้อมูลหลัก ซึ่งเป็น LiveData&lt;&gt;ที่เราแก้ไขไม่ได้ . private val _score = MutableLiveData&lt;Int&gt;() val score:LiveData&lt;Int&gt; . ตัวแปรที่เป็น MultableLiveData สามารถเป็น Private ได้เลย เพราะมีการเข้าถึงเฉพ่าะในคลาส ไม่จำเป็นต้องเปิดต่อข้างนอก ในขณะดียวกัน ตัวแปรที่ข้างนอกเข้ามาแก้ไขได้อย่าง score ก็ถูกกำหนดเป็นชนิดที่ไม่สามารถแก้ไขได้อยู่แล้ว . จากนั้น Override get() Method ของตัวแปร LiveData เช่นดังตัวอย่าง . val score:LiveData&lt;Int&gt; get() = _score .",
    "url": "/tin-android-docs/AndroidFundamental/LiveData.html",
    "relUrl": "/AndroidFundamental/LiveData.html"
  }
  ,"4": {
    "title": "Room Database",
    "content": "Room Database Architecture . การจัดเก็บข้อมูลเป็นสิ่งสำคัญสำหรับทุก ๆ การพัฒนาแอพพลิเคชั่น สำหรับแอนดรอยด์ มันมี By Default อยู่แล้วคือ SQLite Database ซึ่งเป็นฐานข้อมูลแบบ Relational Database วันนี้ผมจะเอาประสบการณ์ที่ผมไปทำใน Code Lab มาอธิบายการทำงานคร่าว ๆ ของ Room Persistance Library หรือ Room Database กัน . Room Persistance Library . Room Persistance Library จะเป็นตัวสร้าง Database ขึ้นมา เรียกว่า Room Database จากนั้นผู้พัฒนาแอพพลิเคชั่นไม่จำเป็นต้องติดต่อกับฐานข้อมูลโดยตรง แต่จะใช้วิธีการสร้าง Data Access Object หรือ DAO เข้ามาแทน . การใช้ Room Database นี้เราสามารถเขียนได้บน Android ทั้งภาษาจาวา และ คอทลิน แต่ที่จะทำนี้จะใช้ภาษา Kotlin เป็นหลักก่อน ที่ผมเขียนเป็นบทความ เพราะเอาไว้โน้ตของผมเองด้วยนะ กลัวจะลืม . . หมายเหตุ ที่จะมาเล่านี้อ้างอิงจาก Android with Kotlin Fundamental Course ใน Google Codelab นะครับ สามารถเข้าไปดูและเรียนได้ ฟรี . สร้างโปรเจกต์ และจัดการ Build.Gradle . เริ่มจากสร้างโปรเจกต์ใน Android Studio แล้วทำการเพิ่ม dependency ลงไปใน Build.gradle ใน Module “app” การเพิ่ม dependency ลงไป มันก็คล้าย ๆ กับการติดตั้ง Library ต่าง ๆ เหมือนใน Node.js ก็จะมี npm install อันนี้ก็คล้าย ๆ กัน โดยเราจะต้องมา define ก่อนว่า จะเอา roomDB เวอร์ชั่นไหน จะได้เป็นตัวแปล จะได้ไม่ต้องเขียนซ้ำหลายครั้ง . dependencies { def room_version = &quot;2.2.0&quot; //Room Database implementation &quot;androidx.room:room-runtime:$room_version&quot; annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot; //Kotlin Exentension for room implementation &quot;androidx.room:room-ktx:$room_version&quot; //.....Dependencies อื่น ๆ .... } . ก็จะเป็นการ implementation runtime worker และ annotate ตัวคอมไพเลอร์ . ไฟล์สำคัญสำหรับการสร้าง และจัดการ Database . 1. Data Class เพื่อเตรียมไว้ใช้ในการสร้าง Table . เตรียมสร้าง Data Class . เริ่มจากสร้างไฟล์ Kotlin (.kt) เปล่า ๆ มาตัวหนึ่ง แล้วเราก็มีตัวแปล หรือ Entity ต่าง ๆ อยู่ในสมอง เราสามารถตั้งชื่อไฟล์นี้ แทนชื่อตารางแบบง่าย ๆ ก็ได้ เช่นผมตั้งว่า SleepNight.kt เราทราบอยู่แล้วว่าในภาษา Kotlin นั้นชื่อไฟล์กับชื่อคลาส ไม่จำเป็นต้องตรงกันก็ได้ ไม่เหมือนใน Java แต่ว่า ตรงกันไว้ก็ดี จากนั้น เราก็เริ่มทำการ Implement dataclass โดยใส่ตัวแปล ที่เราต้องการให้มันเป็น column ใน Database ลงไป . data class SleepNight( var nightId: Long = 0L, val startTimeMilli:Long = System.currentTimeMillis(), var endtimeMilli: Long = startTimeMilli, var sleepQuality: Int = -1 ) . Initial ค่าไปเลยก็ดี จะเห็นว่า data class ใน Kotlin นั้น เราใส่ตัวแปลลงในส่วนของพารามิเตอร์รับค่าเลย data class ในความคิดของผม ผมมองว่าคล้าย ๆ เราสร้าง Stucture ในภาษา C หรือ อื่น ๆ . บอกกับแอนดรอยด์ให้รู้ว่าส่วนนี้ของ Data Class คือส่วนใดของ Table ใน Database . เราจะต้อง define บอกมันให้รู้ว่าส่วนตรงนี้คืออะไร เช่น Attribute นี้เป็น Primary Key หรืออะไรต่าง ๆ เป็นต้น . data class ของเราเป็น entity set หรือ เป็นตารางนั้นเอง เราต้องบอกให้มันรู้ว่ามันเป็นตาราง โดยการเขียนไว้ข้างหน้าว่า . @Entity(tableName = &quot;daily_sleep_quality_table&quot;) data class SleepNight { .... } . | กำหนด Primary Key โดย เราจะบอกว่า ตัวนี้เป็น primary key หน้าตัวแปลของเรา แล้วเราจะใส่ Attribute ควบคุมต่าง ๆ ข้างในวงเล็บ เช่นในตัวอย่างนี้เป็น autoGenerate = true . @PrimaryKey(autoGenerate = true) var nightId:Long = 0L, . | กำหนด ColumnInfo ให้กับตัวคอลัมม์อื่น ๆ ที่ไม่ใช่ Primary Key โดยใช้แทก @ColumnInfo . @ColumnInfo(name=&quot;start_time_milli&quot;) val startTimeMilli:Long = System.currentTimeMillis(), . อย่างน้อยที่สุดก็คือ ใส่ชื่อให้มัน . | . จะสังเกตุว่าตัวแปลต่าง ๆ ที่เขียนใน Java, Kotlin เราจะเขียนเป็น Camel Case อยู่แล้ว แต่ถ้ามันไปอยู่ในมุมของ Physical หรือ ในมุมที่มันจะไปสร้างใน Database เรามักจะเขียนกลับไปเป็นแบบเดิม เช่นมี Underscore หรือ อะไรต่าง ๆ คล้าย ๆ กับภาษา C หรือ รักษา SQL เอาไว้ เพราะมันอาจจะ Implement ได้ง่านกว่า ในตรงนั้น . เมื่อถึงขั้นตอนนี้ โค้ดทั้งหมด ก็จะเป็นประมาณนี้ . 2. สร้าง Data Access Object (Dao) . ตรงนี้คือการสร้างฟังก์ชั่น ขึ้นมา Reference คอมมานด์ หรือ ที่เราเรียกว่า Queries ต่าง ๆ ใน Relational Database นั่นเอง กล่าวคือ Data Access Object จะช่วยให้เราไม่ต้องเขียน Query ยาว ๆ เพียงแต่เรียกเป็นฟังก์ชันสั้น ๆ แค่นั้นเอง โดย Data Access Object จะสร้างอยู่ในรูปแบบของ Interface . ถ้าตามหลักของ OOP Interface คือ โครงสร้างของ Class อันนี้ก็เช่นเดียวกัน คือ มีความสามารถ มี Method อะไรบ้าง Return ค่ามั้ย ถ้า Return จะกลับมาเป็นอะไร รับค่ามั้ย เราจะให้พารามิเตอร์มันชื่ออะไร เป็นลักษณะแบบไหน Int, Float, Char หรือ เป็น User Define Type อย่างที่เราทำ Class, Data Class เราใส่ไปให้หมด โดยไม่ต้อง Implement Method (ที่ Kotlin เรียก fun ) ข้างใน . Interface Feature Listing . ต้องการฟีเจอร์ หรือ Queries อะไรกับ Database บ้าง ลองลิสต์ลงมาก่อนเลย โดยชื่อไฟล์ยังเป็นไฟล์ .kt เหมือนเดิม แต่นิยมตั้งเป็น Dao ตามหลังเช่น SleepDatabaseDao.kt เป็นต้น . interface SleepDatabaseDao{ fun insert(night:SleepNight) fun update(night:SleepNight) fun clear() fun get(key:Long):SleepNight? fun getTonight():SleepNight? fun getAllNight():LiveData&lt;List&lt;SleepNight&gt;&gt; } . บอกให้มันรู้ว่าตรงนี้ เป็นส่วนใดของ Query เป็นส่วนใดของ Database . เหมือนอย่างในขั้นตอนที่แล้ว เราก็จะมี Annotate หน้า Class หรือ Function ตอนนี้ก็เช่นกัน . กำหนดว่า interface นี้ เป็น Data Access Object (Dao) นะ เราก็ใส่ @Dao ไปข้างบน Interface . @Dao interface SleepDatabaseDao ( ...) . | การใส่ Query ให้มัน ให้ถูกต้อง ใช่เนื่องจากมันเป็น Interface เราจะไปสั่งอะไรใน Function / Method มันหละ เราจะใช้วิธีนี้ในการบอกมันก่อนเลยว่า เออ เจอคนสั่งฟังก์ชันนี้มาทำยังไง มีด้วยกัน 2 แบบ คือ ใช้ Query สามัญ ๆ ที่มันมีไว้ให้แล้ว กับเขียน Query ขึ้นเอง เริ่มด้วยสามัญ ๆ . @insert fun insert(night:SleepNight) . ต่อไปมาดูคิวรี่ที่เราสามารถเขียนไปเองได้ โดยเราเองสามารถเอาตัวแปล ที่เราประกาศเป็นตัวรับค่าในฟังก์ชันนั้น มาใช้ได้ โดยใช้เครื่องหมาย : นำหน้าชื่อตัวแปล เช่น :key . @Query(&quot;SELECT * FROM daily_sleep_quality_table WHERE nightId = :key &quot;) fun get(key:Long):SleepNighit? . | . โดยสามารถใช้ SQL Command ต่าง ๆ ได้อยู่แล้ว ถึงตอนนี้ของผมจะได้โค้ดประมาณนี้ แล้วเดี๋ยวเราจะมาสร้าง Database ลงในมือถือของเรากัน . 3. การเอา Database ไปสร้างขึ้นอยู่บนอุปกรณ์แอนดรอยด์ . หลังจากเราวางโครงสร้างของ Database เรียบร้อยแล้ว แต่เรายังไม่สร้าง เราก็จะไปกำหนดคอนฟิก ให้มันสร้าง Database ขึ้นมา คือมันไม่จำเป็นที่จะต้องสร้าง Data base ใหม่ทุกครั้ง ไม่นั้นเครื่อง Client คงความจำเต็มตายเลย . Abstract Class Creation . ต่อมาเราจะสร้าง Database โดยการสร้าง Abstract Class ซึ่ง Abstract Class ใน OOP คือ Class ที่ไม่สามารถสร้าง Object ได้โดยตรง แต่สามารถให้มีการถ่ายทอดไปยัง Class ลูกก่อน แล้ว Class ลูกก็จะ Implement Abstract Method จากนั้น ก็จัดการได้เลย ใน Abstract Class จะมีอย่างน้อย 1 Abstract Method ที่ว่าง ๆ เลย ให้ Class ลูก ไปจัดการ Implement เอาเอง และ Method อื่น ๆ เราสามารถเขียนต่าง ๆ ลงใน Method ได้เลย ว่าจะให้ Method นี้ทำงานอะไร ซึ่งตรงนี้เองที่ทำให้ Abstract Class แตกต่างจาก Interface . ดังนั้นเราจะมาเริ่มสร้าง Database ของเราโดยเริ่มจากสร้าง Class ที่ extend RoomDatabase . abstract class SleepDatabase:RoomDatabase(){ ... } . Implement Database Class . หลังจากนั้นก็จะมีขั้นตอนต่าง ๆ ใน การ Implement Database ของเราดังนี้ . บอกว่า Class นี้คือ Database แน่นอนว่าเราจำเป็นที่จะต้อง Annotate เหมือนทุก ๆ อันที่ผ่านมา โดยครั้งนี้เราต้อง บอก ด้วยว่าเราจะสร้างจาก Class อะไร (ซึ่งก็คือ Class นี้) มี Properties อะไรบ้าง โดยใช้ @Database(entities = [...] , version = ... , exportSchema = ... ดังนี้ . @Database(entities = [SleepDatabase::class],version = 1 ,exportSchema = false) abstract class SleepDatabase:RoomDatabase(){ } . | เอา Data Access Object หรือแหล่งรวม Query ในรูปแบบกำหนดเป็นชื่อฟังก์ชันของเรามาใส่ โดยเราต้องใส่ในรูปแบบของ Abstract Variable ก็ถ้า Abstract Class ไม่มีอะไรเป็น Abstract แล้วเราจะสร้างมันเป็น Abstract ทำไมหละ . abstract val sleepDatabaseDao:SleepDatabaseDao . | สร้าง Companion Object มาใช้ในการให้ไฟล์อื่น ๆ สามารถเจ้าถึง Database หรือ จะ Initial Database ได้ โดยที่ไม่ต้องไปสร้างเป็นตัวอย่าง หรือ เป็น Instance เอง คือผมพูดถูกมั้ย คือเราสร้าง Instance ไปเลย และให่เขาเรียกใช้ได่เลย ไม่ต้องมาสร้าง Instance เองอยู่ . companion object{ } . | สร้างตัวแปรตัวอย่างของเรา หรือ INSTANCE ของเราขึ้นมา อย่างที่บอกไว้คือ ตัวลูก ไม่ต้องสร้างเอง เราสร้างไว้ตรงนี้เลย โดยตัวแปลของ INSTANCE ของเราจะเป็นชนิด SleepDatabase ก็คือ เรากำลังสร้าง Database ที่มี Table SleepDatabase ที่เราเขียนโครงสร้างของตารางมาแล้วด้านบน . โดยเราจะมีการกำหนดนิดนึงว่า ตัวแปลรัวนี้จะเป็นตัวแปรรูปแบบ @Volatile คือ เราจะไม่ขออยู่ใน Cache ขออยู่ใน Memory ไปเลย จะทำให้ ตัวแปร INSTANCE หรือ ตัวแปรแทนโครงสร้างตารางเนี่ย ไม่อยู่ใน Cache เราจะได้ไม่ต้องกลัวปัญหาว่า มันจะตรงกันหรือเปล่า ใน Cache กับ ใน RAM เรายอมอาจจะช้าลงนิดนึง แต่ชั่วร์ . โดยเราจะสร้างตัวแปรเป็น Nullable และ ตั้งค่าเริ่มต้นเป็น null และเป็นตัวแปรแบบเปลี่ยนค่าได้ . private var INSTANCE : SleepDatabase? = null . ที่เราตั้งเป็น Null ก็เพราะว่า โอเค ตอนนี้ INSTANCE เทียบได้กับDatabase ที่เราจะสร้างแล้ว แต่ว่า เราจะยังไม่สร้าง เราจะตรวจสอบก่อนว่าตอนนี้ มันมีอยู่แล้ว หรือ ไม่ อย่าลืมว่า เราอาจจะไม่ได้ build หรือ Install / Run App นี้ครั้งเดียว ในระหว่าง การพัฒนา ดังนั้น เราจะเช็คก่อนว่า Database มีอยู่แล้วหรือไม่ ถ้ามีก็ไม่ต้องสร้าง ถ้าไม่มี ก็สร้าง จะได้ไม่ซับซ้อนด้วย . | Synchronyze Program แล้วดูว่า instance ของเรามีอยู่หรือไม่ เราจะใช้การ Smart Cast สร้างตัวแปลใน loop ไม่สิ ใน Function นี้อีกตัว เป็นการ Copy มาจะได้ไม่มีปัญหาค่าซ้ำซ้อนของตัวแปร แล้วค่อยส่งค่ากลับไป . synchronized(this){ var instance = INSTANCE ... return instance } . | เช็คว่า Database ถูกสร้างแล้วหรือยัง ข้างต้นนี้ คือ Database ถูกสร้างแล้ว Return มันกลับไปเลย แต่ถ้า instance เป็น null เราจะสร้าง Database มันขึ้นมา โดยสิ่งต่อไปนี้ยังอยู่ใน Scope ของ synchronized(this){ } นะ ก่อน return ด้วย . if(instance == null){ instance = Room.databaseBuilder( context.applicationContext, SleepDatabase::class.java, &quot;sleep_history_database&quot; ).fallbackToDestructiveMigration().build() } . ดูจากโค้ดเราก็จะพบว่า เราจะสร้าง instance ให้เป็นค่าใดค่าหนึ่ง นั่นก็คือ เป็น Room และเรียกใช้ DatabaseBuilder โดยยึดจาก Class SleepDatabase ก็คือ Class นี้ และใช้ชื่อ sleep_history_database จากนั้นจึงสั่ง fallbackToDestructiveMigration() และ build() ก่อนจะ Return ออกไป เป็น Instance . | . จากขั้นตอนทั้งหมด ของส่วนที่ 3 นี้ จะมี Source Code ทั้งหมดเป็นดังนี้ . ทั้งหมดนี้ ก็คือการสร้าง Database เริ่มต้นในโปรแกรมของเรา โดยสร้างผ่าน Room Database บน Android ตรงนี้ยังไม่พูดถึงการใช้ UI จากฝั่งผู้ใช้มา Connect หรือ Interact กับโปรแกรมของเรา ซึ่งตรงนี้เราก็อาจจะไปดีไซด์ Layout แล้ว ใช้รูปแบบต่าง ๆ ในการ Map View ของเรา เข้ากับ Model ของเราตรงนี้ ได้ ไม่ว่าจะเป็น Model View Controller (MVC), Model View Presenter (MVP) หรือ Model View ViewModel (MVVM) ก็ได้ .",
    "url": "/tin-android-docs/AndroidFundamental/RoomDatabaseBasic.html",
    "relUrl": "/AndroidFundamental/RoomDatabaseBasic.html"
  }
  ,"5": {
    "title": "ViewModel and ViewModel Factory",
    "content": "ViewModel and ViewModelFactory . Program Bootstrap with Viewmodel and ViewModelFactory Starter Code from Google Codelabs from this link Code Lab Link . Meaning of ViewModel and ViewModelFactory . ViewModel is class to store and manage UI-related data, it allow data survive in device configure saturation (like screen rotation). | ViewModelFactory is class to instantiate and return ViewModel | . Managing Configuration Changes Problem . Configure change like screen rotation, screen close or anything can make program run into problem the ViewModelFactory can make the ViewModel use in many configure change. . For handling th problem of configure changes can use savedInstanceState() to save and store device configure like screen rotation but it’s too mush lines of codes and can store minimum data. It more than useful if use Design under Android Architecture Guideline (lifecycle).It more better to seperate UI Controller , ViewModel and ViewModelFactory and make it under Seperation of Concern . Seperation of Concern . UI Controller must only contain logic to handle UI, no decision making logic | ViewModel hold data to Display,Simple Calculate and Transformation, decision making | ViewModelFactory contains business logic to perform simple calculation and decide of ViewModel | . In Configure Change like screen-rotation fragment will be destroy but ViewModel is still alive . ViewModelProvider . If we use viewModel instance using ViewModel class, object will create everytime when fragment is re-created. For the better result we can Instance ViewModel using ViewModelProvider . ViewModelProvider() return existing ViewModel (if exists) or create a new one if not exist will Create ViewModel instance in association with given scope | ViewModelProviders.of() is for Initial ViewModel use that To Create ViewModelProvider like . viewModel = ViewModelProviders.of(this).get(GameViewModel::class.java) . inside of is FragmentActivity so this refer to fragment and .get() is get the model to make this is fragment activity. . | . ViewModelFactory . Sometimes the value must pass to viewModel at the initialization part, so we have the problem that we pass value and it don’t affect UI because the initialization is running out. Factory Method Pattern is the way to let ViewModel wait for value to initialize or another logic that programmer want and then we pass value into ViewModel on Initialization part. . ViewModelFactory uses factory to create objects while Factory method is a method that return the copy of the same class. . ViewModelFactory Class . ViewModelFactory Class will take responsible for make a copy of that ViewModel object it will extend from ViewModelProvider.Factory . class ScoreViewModelFactory(private val finalScore: Int):ViewModelProvider.Factory{} . After we write the prototype of this class IDE will automatically appear error that we are not implement abstract method. . The Solution to solve this is to override create method that will let modelClass to create ViewModel class like this . override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T { // If model class is correct return them as ViewModel with Value if(modelClass.isAssignableFrom(ScoreViewModel::class.java)){ return ScoreViewModel(finalScore) as T } throw IllegalArgumentException(&quot;Unknown ViewModel Class&quot;) } . Create ViewModel From ViewModel Factory Class . Initial value of viewModelFactory Variable by Pass the value from argument bundle as a constructor of Factory class . private lateinit var viewModelFactory: ScoreViewModelFactory viewModelFactory = ScoreViewModelFactory(ScoreFragmentArgs.fromBundle(arguments!!).score) . | Create ViewModel from ViewModelFactory . private lateinit var viewModel:ScoreViewModel viewModel = ViewModelProviders.of(this,viewModelFactory).get(ScoreViewModel::class.java) . | .",
    "url": "/tin-android-docs/AndroidFundamental/ViewModel.html",
    "relUrl": "/AndroidFundamental/ViewModel.html"
  }
  ,"6": {
    "title": "About",
    "content": "",
    "url": "/tin-android-docs/about/",
    "relUrl": "/about/"
  }
  ,"7": {
    "title": "Theethawat Android Documents",
    "content": "Theethawat Android Documents . Note of my work on Android for make me know when I am forgotten. . This is the part of Project E-health for Personal Sensor Application (Android Application) . I has prepare my android skill for this project, the docs will be in Thai and English and If I have enough time after finish my project, I will make it complete in 2 languages. Somedata is mistake can Improve it by tell me at theethawat.s@outlook.co.th. or make an issue or pull request in GitHub. . Powered By Jekyll - Just the Docs . Theethawat Savastham, Hatyai Songkhla, Thailand. .",
    "url": "/tin-android-docs/",
    "relUrl": "/"
  }
  
}